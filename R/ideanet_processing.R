devtools::load_all("~/Desktop/ideanet/")

# Read in data
rcScaled <- read.csv("~/Desktop/RCnets/ICPSR_37453/rcScaled.csv") %>%
  dplyr::mutate(CASEID = as.character(CASEID))
# Create a city*time indicator to process all networks at once
rcScaled$net_id <- paste(rcScaled$city, rcScaled$round, sep = "_")


#### Read in meaningful NULL edges (we'll come back to this later)
rcMissing <- read.csv("~/Desktop/RCnets/ICPSR_37453/rcMissing.csv") %>%
  dplyr::mutate(CASEID = as.character(CASEID))
# Create a city*time indicator to process all networks at once
rcMissing$net_id <- paste(rcMissing$city, rcMissing$round, sep = "_")


#### Create combined edgelist of actual scores and null ties
combined_el <- dplyr::bind_rows(rcScaled,
                                rcMissing)

# Make nodelist for each time period
nodelist_mode1 <- rcScaled %>%
  dplyr::group_by(city, round, CASEID, WORKGROUP) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(mode = 1) %>%
  dplyr::select(city, round, node_id = CASEID, mode, WORKGROUP)

nodelist_mode2 <- rcScaled %>%
  dplyr::group_by(city, round, alter) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(mode = 2,
                WORKGROUP = alter) %>%
  dplyr::select(city, round, node_id = alter, mode, WORKGROUP)

rc_nodelist <- dplyr::bind_rows(nodelist_mode1,
                                nodelist_mode2) %>%
  dplyr::mutate(net_id = paste(city, round, sep = "_")) %>%
  dplyr::select(net_id, node_id, city, round, mode, WORKGROUP) %>%
  dplyr::arrange(net_id, mode)

rc_nodelist2 <- rc_nodelist %>%
  dplyr::select(-net_id) %>%
  dplyr::mutate(in_wave = TRUE) %>%
  tidyr::pivot_wider(names_from = round,
                     values_from = in_wave,
                     values_fill = FALSE,
                     names_prefix = "round")

# Step 1 - Choose type of network
##### This is based on the particular dataset you read in and
##### then how you filter type. Make cleaned version of this later


# Step 2 - Filter edgelist based on threshold
strong_thresh <- 4
weak_thresh <- 3.5

strong_el <- rcScaled %>%
  dplyr::filter(weight > strong_thresh)

weak_el <- rcScaled %>%
  dplyr::filter(weight < weak_thresh)


# Step 3 - Process networks

strong_nw <- netwrite(edge_netid = strong_el$city,
                      edge_time = strong_el$round,
                      i_elements = strong_el$CASEID,
                      j_elements = strong_el$alter,
                      # weights = strong_el$weight,

                      nodelist = rc_nodelist2,
                      node_netid = "city",
                      node_id = "node_id",
                      node_time = c("round1", "round2", "round3", "round4"),

                      bipartite = TRUE,
                      within_fun = mean,
                      shiny = TRUE)





# Step 4 - Customize visualization (color by role group)

color_nodes <- function(x) {

  for (i in 1:length(x)){

    for (j in 1:4) {
      this_igraph <- x[[i]][[j]]$full_graph$network

      # Get color variable values
      color_vec <- data.frame(value = igraph::V(this_igraph)$WORKGROUP)

      # Create data frame of color links
      color_link <- data.frame(value = c("parole", "family_social", "research", "city_govt",
                                         "health", "youth_out", "police", "school", "probation",
                                         "corrections", "da_office", "emp_devel", "faith_based"),
                               color = c("#ED90A4", "#E3997F", "#D0A45F", "#B3AF4F", "#8DB85E",
                                         "#5BBE7E", "#00C1A1", "#00C0C2", "#3DB9DB", "#84ADEA",
                                         "#B79FEB", "#D993DE", "#EA8DC5"))

      # Merge in color values
      color_vec <- color_vec %>%
        dplyr::left_join(color_link, by = "value")

      igraph::V(this_igraph)$color <- color_vec$color

      x[[i]][[j]]$full_graph$network <- this_igraph

    }
  }

  return(x)
}


# Function for better plot layouts
layout_iso <- function(graph,
                       layout_fun = igraph::layout_with_fr,
                       isolate_dist = .25) {
  # browser()

  # Make empty matrix of coordinates
  layout_iso <- matrix(NA, nrow = igraph::vcount(graph), ncol = 2)

  # Identify non-isolates
  non_iso <- which(igraph::degree(graph) != 0)
  # Extract non-isolates from igraph object
  non_iso_graph <- igraph::induced_subgraph(graph, non_iso)

  # Store coordinates generated by `layout_fun` on main component
  non_iso_coords <- layout_fun(non_iso_graph)

  # Assign these coords to their respective place in the
  # `layout_iso` matrix
  layout_iso[non_iso, 1] <- non_iso_coords[, 1]
  layout_iso[non_iso, 2] <- non_iso_coords[, 2]

  # Determine values for isolates in new layout
  layout_iso[which(is.na(layout_iso[,2])), 2] <- floor(min(layout_iso[,2], na.rm = TRUE)) - isolate_dist
  layout_iso[which(is.na(layout_iso[,1])), 1] <- seq(from = min(layout_iso[,1], na.rm = TRUE),
                                                     to = max(layout_iso[,1], na.rm = TRUE),
                                                     length.out = sum(is.na(layout_iso[,1])))

  return(layout_iso)
}


strong_nw <- color_nodes(strong_nw)


### City A, Time 1, Full RC Scale
plot(strong_nw$network2$time1$full_graph$network,
     layout = layout_iso(strong_nw$network2$time1$full_graph$network))

### City B, Time 1, Full RC Scale
plot(strong_nw$network1$time1$full_graph$network,
     layout = layout_iso(strong_nw$network1$time1$full_graph$network))

### City A, All Waves, Full RC Scale
par(mfrow = c(2, 2))
plot(strong_nw$network2$time1$full_graph$network,
     layout = layout_iso(strong_nw$network2$time1$full_graph$network))
plot(strong_nw$network2$time2$full_graph$network,
     layout = layout_iso(strong_nw$network2$time2$full_graph$network))
plot(strong_nw$network2$time3$full_graph$network,
     layout = layout_iso(strong_nw$network2$time3$full_graph$network))
plot(strong_nw$network2$time4$full_graph$network,
     layout = layout_iso(strong_nw$network2$time4$full_graph$network))

### City B, All Waves, Full RC Scale
par(mfrow = c(2, 2))
plot(strong_nw$network1$time1$full_graph$network,
     layout = layout_iso(strong_nw$network1$time1$full_graph$network))
plot(strong_nw$network1$time2$full_graph$network,
     layout = layout_iso(strong_nw$network1$time2$full_graph$network))
plot(strong_nw$network1$time3$full_graph$network,
     layout = layout_iso(strong_nw$network1$time3$full_graph$network))
plot(strong_nw$network1$time4$full_graph$network,
     layout = layout_iso(strong_nw$network1$time4$full_graph$network))




# Step 5 - Aggregate node-level measures

within_net <- function(x) {

  # browser()

  for (i in 1:length(x)) {
    these_nodes <- x[[i]]$full_graph$node_measures

    # if (!stringr::str_detect(names(x)[i], "time\\d*$")) {
    #   these_nodes$net_id <- names(x)[i]
    # }

    if (i == 1) {
      temp_df <- these_nodes
    } else {
      temp_df <- dplyr::bind_rows(temp_df, these_nodes)
    }
  }

  return(temp_df)
}

agg_node <- function(x) {

  # browser()

  if (FALSE %in% stringr::str_detect(names(x), "time\\d*$")) {
      temp_dfs <- dplyr::bind_rows(lapply(x, within_net))
  } else {
      temp_dfs <- within_net(x)
  }

  return(temp_dfs)

}

nodes_processed <- agg_node(strong_nw) %>%
  dplyr::select(-id) %>%
  dplyr::select(wave, dplyr::everything()) %>%
  tidyr::pivot_wider(id_cols = node_id:name,
                     names_from = wave,
                     values_from = degree:in_largest_bicomponent,
                     names_prefix = "time")


within_sys <- function(x) {
  for (i in 1:length(x)) {
    this_df <- x[[i]]$full_graph$system_level_measures

    names(this_df)[3] <- names(x)[i]

    if (i == 1) {
      temp_df <- this_df
    } else {
      temp_df <- dplyr::left_join(temp_df, this_df, by = c("measure_labels", "measure_descriptions"))
    }
  }
  return(temp_df)
}


agg_sys <- function(x) {
  # browser()

  if (FALSE %in% stringr::str_detect(names(x), "time\\d*$")) {
    temp_list <- lapply(x, within_sys)

    for (i in 1:length(temp_list)) {
      colnames(temp_list[[i]])[3:ncol(temp_list[[i]])] <- paste(names(x)[i], colnames(temp_list[[i]])[3:ncol(temp_list[[i]])], sep = "_")

      if (i == 1) {
        temp_dfs <- temp_list[[i]]
      } else {
        temp_dfs <- dplyr::left_join(temp_dfs,
                                     temp_list[[i]],
                                     by = c("measure_labels", "measure_descriptions"))
      }

    }

  } else {
    temp_dfs <- within_sys(x)
  }

  return(temp_dfs)

}

system_processed <- agg_sys(strong_nw)



# for (i in 1:length(strong_nw)) {
#   this_netid <- names(strong_nw)[i]
#   this_city <- stringr::str_split(this_netid, "_")[[1]][1]
#   this_time <- stringr::str_split(this_netid, "_")[[1]][2]
#
#   these_nodes <- strong_nw[[i]]$full_graph$node_measures %>%
#     dplyr::mutate(city = this_city,
#                   time = this_time) %>%
#     dplyr::select(id, name, mode, city, time, dplyr::everything()) %>%
#     dplyr::select(-id)
#
#   this_system <- strong_nw[[i]]$full_graph$system_level_measures
#   names(this_system)[3] <- this_netid
#
#   if (i == 1) {
#     nodes_processed <- these_nodes
#     system_processed <- this_system
#   } else {
#     nodes_processed <- dplyr::bind_rows(nodes_processed, these_nodes)
#     system_processed <- system_processed %>%
#       dplyr::left_join(this_system, by = c("measure_labels", "measure_descriptions"))
#   }
#
# }


# Step 6 - If a particular respondent wasn't present in a previous wave,
# replace missing values for preceding waves with the average value of
# responses from within the same role group for those waves

# Pivoting wider so variables for each time are in adjacent columns
# rather than separate rows
# nodes_processed2 <- nodes_processed %>%
#   dplyr::select(-net_id) %>%
#   tidyr::pivot_wider(id_cols = c("name", "mode", "city", "WORKGROUP"),
#                      names_from = time,
#                      values_from = degree:in_largest_bicomponent,
#                      names_prefix = "time")

# But now we need to pivot longer for merging in mean values
nodes_processed2_long <- nodes_processed %>%
  tidyr::pivot_longer(cols = degree_time1:in_largest_bicomponent_time4,
                      names_to = "varname",
                      values_to = "value")


# Get within-mode averages for each time period
### We'll use this to replace `NA` values for mode 1
mean_vals <- nodes_processed %>%
  dplyr::select(-name, -node_id) %>%
  dplyr::group_by(city, mode, WORKGROUP) %>%
  dplyr::summarize_all(mean, na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  tidyr::pivot_longer(cols = degree_time1:in_largest_bicomponent_time4,
                      names_to = "varname",
                      values_to = "value2")

# Merge in and substitute NAs with mean values
nodes_processed3 <- nodes_processed2_long %>%
  dplyr::left_join(mean_vals, by = c("city", "mode", "varname", "WORKGROUP")) %>%
  dplyr::mutate(final_val = ifelse(is.na(value), value2, value),
                final_val = ifelse(is.nan(final_val), NA, final_val)) %>%
  dplyr::select(name, city, mode, WORKGROUP, varname, value = final_val) %>%
  tidyr::pivot_wider(names_from = "varname",
                     values_from = "value")

# Notes: If NAs persist, it's because there weren't any respondents from
# that role group in the preceding wave (or they didn't meet the backbone threshold)
# Also, currently merging in mean values for future waves if a respondent
# leaves the network after an earlier wave. Don't know if we want to avoid this.


# Step 7 - Visualize Changes in System-Level Properties Over Time
#### Good to go, just remind me which cities had the intervention so I can
#### label that in the plots
system_plot <- function(df = system_processed,
                        vars = NULL) {

  df2 <- df[df$measure_labels %in% vars,] %>%
    tidyr::pivot_longer(cols = `network1_time1`:`network4_time4`,
                        names_to = "wave",
                        values_to = "value") %>%
    dplyr::mutate(city = as.factor(stringr::str_extract(wave, "^network\\d")),
                  city = stringr::str_replace(city, "network", ""),
                  wave = as.numeric(stringr::str_extract(wave, "\\d$")),
                  value = as.numeric(value),
                  measure_labels = as.factor(measure_labels)) %>%
    dplyr::mutate(intervention = dplyr::case_when(city == 1 ~ TRUE,
                                                  city == 2 ~ TRUE,
                                                  city == 3 ~ FALSE,
                                                  city == 4 ~ FALSE,
                                                  TRUE ~ NA))


    df2 %>%
      ggplot2::ggplot(ggplot2::aes(x = wave,
                                   y = value,
                                   color = city,
                                   linetype = intervention)) +
      ggplot2::geom_point() +
      ggplot2::geom_line() +
      ggplot2::theme_classic() +
      ggplot2::labs(title = vars)

}

sysplot_list <- list()
names_vec <- c()

for (i in 1:nrow(system_processed)) {

  num_check <- as.numeric(system_processed[i,3])

  if (is.na(num_check)) {
    next
  } else {
    sysplot_list[[(length(sysplot_list)+1)]] <- system_plot(vars = system_processed[i,1])
    names_vec <- c(names_vec, system_processed[i,1])
  }

}

names(sysplot_list) <- names_vec

sysplot_list$`Number of Ties`
sysplot_list$`Number of isolates`

sysplot_list$`Mean Degree (Mode 1`
sysplot_list$`Mean Degree (Mode 2`
sysplot_list$Density

sysplot_list$`Average Geodesic`

sysplot_list$`Global Clustering Coefficient (Mode 1`
sysplot_list$`Global Clustering Coefficient (Mode 2`
sysplot_list$`Global Clustering Coefficient (Full Graph`
sysplot_list$`Global Clustering Coefficient (Alternate`

sysplot_list$`Gini Coefficient, Degree (Mode 1`
sysplot_list$`Gini Coefficient, Degree (Mode 2`

#####################################
# Adding NULL edges to visualizations

node_id_nodelist <- rc_nodelist2 %>%
  dplyr::select(CASEID = node_id, dplyr::starts_with("round"))

rcMissing2 <- rcMissing %>%
  dplyr::left_join(node_id_nodelist, by = "CASEID") %>%
  dplyr::mutate(keep = dplyr::case_when(round == 1 & round1 == TRUE ~ TRUE,
                                        round == 2 & round2 == TRUE ~ TRUE,
                                        round == 3 & round3 == TRUE ~ TRUE,
                                        round == 4 & round4 == TRUE ~ TRUE,
                                        TRUE ~ FALSE)) %>%
  dplyr::filter(keep == TRUE) %>%
  dplyr::select(-dplyr::starts_with("round"), -keep)



combined_el <- dplyr::bind_rows(strong_el,
                                rcMissing2)



# Apply `netwrite` to null networks

null_nw <- netwrite(edge_netid = combined_el$net_id,
                      i_elements = combined_el$CASEID,
                      j_elements = combined_el$alter,
                      weights = combined_el$weight,

                      nodelist = rc_nodelist,
                      node_netid = "net_id",
                      node_id = "node_id",

                      bipartite = TRUE,
                      within_fun = mean)

for (i in 1:length(null_nw)){

  this_igraph <- null_nw[[i]]$full_graph$network

  # Get color variable values
  color_vec <- data.frame(value = igraph::V(this_igraph)$WORKGROUP)

  # Create data frame of color links
  color_link <- data.frame(value = c("parole", "family_social", "research", "city_govt",
                                     "health", "youth_out", "police", "school", "probation",
                                     "corrections", "da_office", "emp_devel", "faith_based"),
                           color = c("#ED90A4", "#E3997F", "#D0A45F", "#B3AF4F", "#8DB85E",
                                     "#5BBE7E", "#00C1A1", "#00C0C2", "#3DB9DB", "#84ADEA",
                                     "#B79FEB", "#D993DE", "#EA8DC5"))

  # Merge in color values
  color_vec <- color_vec %>%
    dplyr::left_join(color_link, by = "value")

  igraph::V(this_igraph)$color <- color_vec$color

  igraph::E(this_igraph)$color <- ifelse(igraph::E(this_igraph)$weight == .5, "orange", "grey")

  # igraph::E(this_igraph)$color <- ifelse()

  null_nw[[i]]$full_graph$network <- this_igraph

}



par(mfrow = c(1,1))

plot(null_nw$`1_1`$full_graph$network,
     layout = layout_iso(null_nw$`1_1`$full_graph$network))


test <- igraph::union(scaled_nw$`1_2`$full_graph$network,
                      null_nw$`1_2`$full_graph$network)

igraph::V(test)$color_2

plot(test,
     vertex.color = igraph::V(test)$color_1)
